# O(N)으로 해결해버리는 방법

## 투 포인터
어떤 특정 조건을 만족하는 연속 구간을 구할 때, `O(N)` 으로 해결할 수 있는 알고리즘

2개의 포인터를 이용해서 구간의 길이 가변적을 잡아가면서 만족하는 구간을 모두 찾는다.

각 포인터가 움직이기 때문에 시간 복잡도는 N + N = 2N 이며, 어떤 구간을 찾는 문제가 입력이 아주 클 때 유용하다.

대표적인 유형은 다음과 같다.
1. 포인터 2개가 같은 방향에서 진행하는 유형
2. 포인터 1개는 왼쪽 끝, 오른쪽 끝에서 진행하는 유형

먼저 첫 번째 유형을 분석해보자.

### 구간의 합이 M이 되는 것이 몇 개 있는지 찾는 문제에서는 3가지 분기로 생각할 수 있다.

1. 현재 구간의 합이 M보다 작다면
```cpp
before : [1 2 3] 4 5 6 7
after  : [1 2 3 4] 5 6 7

end의 포인터를 증가시킨후, 구간의 합에 더해준다.
```

2. 현재 구간의 합이 M보다 크다면
```cpp
before : [1 2 3 4] 5 6 7
after  : 1 [2 3 4] 5 6 7

start가 가리키는 값을 구간의 합에서 빼주고, start의 포인터를 증가시킨다.
```

3. 현재 구간의 합이 M과 같다면
```cpp
before : 1 [2 3 4] 5 6 7
after  : 1 2 [3 4 5] 6 7

answer++ 하고,
start가 가리키는 값은 구간의 합에서 빼주고, start의 포인터를 증가시킨다.
end의 포인터를 증가시킨 후, end가 가리키는 값은 구간의 합에 더해준다.
```


### 포인터 2개가 서로 양 끝에서 진행하는 경우
보통 이런 문제는 정렬을 한 후에 결정하는 문제가 많다.

start의 포인터 방향은 `->` 가 될 것이고, end의 포인터 방향은 `<-`가 될 것이다.

이랬을 때, 마찬가지로 특정한 합을 만족하는 방법을 찾을 때 유용하다.

1. 입력된 배열을 오름차순으로 정렬한다.
2. 양쪽 끝의 두 포인터가 가리키는 원소끼리 더해서 최대한 특정한 합을 만족하게 된다면 갱신을 하면서 진행한다.

예를 들어 두 합이 0에 가깝도록 하고 싶다면, 아래와 같은 판단으로 start 포인터를 증가시킬지, end 포인터를 증가시킬지 정할 수 있다.

1. arr[start] + arr[end] < 0 일 때
```cpp
사전에 정렬을 했기 때문에
가장 양 끝 쪽의 합을 구했을 때 0보다 작은 음수가 나온다면?
어느쪽의 포인터를 옮겨야 더 0에 가까울 수 있을까?
바로 왼쪽 start 포인터다.  이 뜻은 가장 작은 값보다 좀 더 큰 값으로 대체하기 때문이다.

그래서 start 포인터를 +1 증가시킨다.
```
2. arr[start] + arr[end] > 0 일 때
```cpp
가장 양 끝 쪽의 합을 구했을 때 0보다 큰 수가 나온다면?
더 작게 만들어야 하기 때문에 end 의 포인터를 감소시키면 된다.
그래서 end 포인터를 -1 감소시킨다.
```
3. 그러면 언제 정답을 찾나요?
```cpp
구해진 합이 정답 값과 비교해서 절대값의 합이 더 작은 쪽으로 갱신을 해나가면 된다.
-1 과 2 중 머가 더 0에 가까울까?
절대값으로 따지면 -1이 쫌 더 0과 가깝기 때문에, 절대값으로 비교를 판단한다.

그런데 정답을 구하는 과정에서 이미 0을 만족하는 경우가 있다면?
문제에 따라 다르지만 특정 조건을 만족하는 경우를 여러 개 찾는다면 계속 진행하고, 아니라면 종료시키면 된다.
```

## Prefix Sum (누적합)
i ~ j 까지 합을 알려달라는 Query(질의어)가 많이 나온다면, 미리 그 구간들의 합을 저장해놨다가 알려주면 더 빠르지 않을까?

array[] = {1, 2, 3, 4, 5} 라는 입력이 들어왔을 때,

2 ~ 4 구간 합을 알려주세요라는 주문을 받았을 때 미리 답을 알고 있다면 더 빠르게 응답할 수 있을 것이다.

이런 것을 사전에 미리 구간의 합을 저장해놓고 질의어가 나올 때 배열의 Random Access 접근을 이용하여 O(1)에 대답할 수 있다.
```cpp
for(int i = 0; i < N; i++)
{
  sum[i] = sum[i - 1] + arr[i];
}
```

## Sliding Window Algorithm (슬라이딩 윈도우)
창문을 옆으로 밀듯이 진행하는 알고리즘이다.

기본 아이디어는 한 칸 오른쪽으로 옮기면 (w - 1)개의 칸은 겹친다는 것에서 도출된 아이디어다.

창문을 옮길때마다 W개를 전부 다 더하는 작업은 하지 말고, 이전의 결과를 써먹는 방향으로 접근하는 방식으로

기존에 모든 창문 위치마다 O(W)에 합을 구해서 전체 시간 복잡도를 O(NW)를 가지게 됬다면,

Sliding Window 를 적용하여 맨 처음 창문에 대해서만 O(W) 작업을 진행하고,

이후에 한 칸씩 밀때에는 O(1)에 구간의 합을 구할 수 있다.

따라서 전체 시간복잡도가 O(N)으로 나오게 된다.
```cpp
Before : [A 1 2 3 4] B
After  : A [1 2 3 4 B]

A~4까지를 포함하는 창문에서의 합은 A + 1 + 2 + 3 + 4
오른쪽으로 한 칸 밀었더니     합은 1 + 2 + 3 + 4 + B

차이점은?
A가 빠지고, B가 더해졌다.

즉, (1 + 2 + 3 + 4) 라는 중복 합에서 A를 빼고, B를 더하는 계산은 O(1) 만에 해결할 수 있다는 것이다.
처음에 창문의 합을 구했더라면 이후에 움직이는 창문들의 합은 빼고, 더하고만 반복하면 O(N)으로 해결할 수 있게 된다.
```

## Anagram (애나그램)
알파벳의 구성은 유지한 채로 순서만 뒤바뀐 단어 관계를 Anagram이라고 한다.

```cpp
Str1 = "abr"
Str2 = "abracadabra"
가 주어졌을 때, Str2의 부분 문자열 중 Str1과 같은 것이 몇 개인지?

[a b r] a c a d a b r a : 1
a [b r a] c a d a b r a
a b [r a c] a d a b r a
a b r [a c a] d a b r a
a b r a [c a d] a b r a
a b r a c [a d a] b r a
a b r a c a [d a b] r a
a b r a c a d [a b r] a : 2
a b r a c a d a [b r a] : 3

이전의 결과를 써먹는 방향으로 접근한다.
알파벳의 갱신에 드는 비용을 O(1) 로 줄이면서 같은 것이 몇 개 인지를 판별하는 방법이다.
```
