# DFS (Depth First Search, 깊이 우선 탐색)
그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘

특정한 경로로 탐색하다가 특정한 상황에서 최대한 깊숙히 들어가서 노드를 방문한 후, 다시 돌아와 다른 경로로 탐색하는 알고리즘이다.

중요한 건 모든 노드을 한 번씩만 방문한다는 점이다. `그래프 탐색 알고리즘 중 하나`

## 동작 방식
1. 탐색 시작 노드를 스택에 삽입하고 방문 처리한다.
2. 스택의 최상단 노드에 방문하지 않은 인접 노드가 있다면 그 인접 노드를 스택에 넣고 방문 처리를 한다. 방문하지 않은 인접 노드가 없다면 스택에서 최상단 노드를 꺼낸다.
3. 1~2 과정을 반복하며, 스택이 비어있을 때까지 반복한다.

`방문 처리` 스택에 한 번 삽입되어 처리된 노드가 다시 삽입하지 않게 체크하는 것, 방문 처리를 함으로써 각 노드를 한 번씩만 처리하게 된다.

## 그래프 표현 방식
`인접 행렬` : 2차원 배열 형태로 그래프의 연결 관계를 표현하는 방식
- 노드의 개수가 많아질수록 모든 관계를 저장하기 때문에 메모리가 불필요하게 낭비된다. 다만, `완전 그래프`에서는 높은 효율을 보여준다.
- 어떤 노드와 어떤 노드의 연결 관계를 `O(1)`에 알 수 있다. (1이면 연결, 0이면 연결되지 않음)

`인접 리스트` : 리스트로 그래프의 연결 관계를 표현하는 방식
- 연결된 정보만 저장하기 때문에 메모리를 효율적으로 사용한다. (노드의 개수가 많고, 간선이 적다면 효율적이다.)
- 어떤 노드와 어떤 노드의 연결 관계를 `O(V)`에 알 수 있다.

위에서 배운 `DFS`를 인접 행렬로 구현하게 되면 시간 복잡도는 `O(V^2)`, 인접 리스트로 구현하게 되면 시간 복잡도는 `O(V + E)`

## 완전 탐색 (Brute-Force, Exhaustive Search)
`완전 탐색` : 모든 경우의 수를 다 체크해서 정답을 해결하는 알고리즘 (무식한 방법)
DFS를 꼭 그래프 탐색으로만 분류되는 것이 아니라, 어떤 모든 경우를 살펴보는 것도 DFS라 불릴 수 있다.

대표적으로 완전 탐색 유형들은 `재귀`, `반복문`을 통해서 모든 경우의 수를 확인하는 방법이며, <br>
DFS로 접근할 시 갈 수 있을 때까지 진행하다가 더이상 진행할 수 없을때 뒤로 후진하여 다시 탐색하게 된다.

ex) 비밀번호 4자리 뚫기, 조합, 순열, DFS, BFS etc...
