# Algorithm 개념 정리

## 다이나믹 프로그래밍 (DP, DynamicProgramming)
이 기법은 메모리 공간을 더 사용하여 연산 속도를 빠르게 증가시키는 방법이다.    
시간을 빠르게 하기 위해 메모리를 더 사용하는 방법(희생하는 방법), 시간과 공간을 `Trade-off`


### 피보나치 수열(Fibonacci Sequence)
```
1 1 2 3 5 8 13 21 34 55 89 ...

f(1) = 1, f(2) = 1, f(n) = f(n-1) + f(n-2) (n>=3)
```

위를 구현할 때
```cpp
int Fibonacci(int n)
{
  if(x == 1 || x == 2) return 1;
  return Fibonacci(n - 1) + Fibonacci(n - 2);
}
```
재귀함수로 구현할 수 있지만, 문제점이 존재한다. *바로 구했던 연산을 또 다시 구한다*는 것이다.    
f(5)를 구한다고 하면   
f(5) = f(4) + `f(3)`       
f(4) = `f(3)` + f(2)        
f(3) = f(2) + f(1)      
f(2) = 1, f(1) = 1

`f(3)`만 해도 두 번씩이나 구하고 있는걸 볼 수 있다. n의 값이 커지면 커질수록 수행 시간이 기하급수적으로 높아지기 때문에 이러한 방식으로 구현하게 되면 
n이 큰 상황에서는 구할 수 없을지도 모른다. 재귀함수로 구현했을 때의 시간 복잡도는 대략 `O(2^N)`정도 된다. 이는 한 함수 안에 같은 함수를 2번 호출하기 때문에
깊이가 깊어질수록 커지게 된다.    

### 피보나치 수열을 효과적으로 구하기
기존에 문제점은 같은 연산을 반복해서 수행한다는 점이다. 따라서 내가 한 번이라도 구했던 연산은 어딘가에 저장하는 방식을 이용하는 것이다.
그 방법을 `Memoization(메모이제이션)`이라고 하며, 구했던 결과를 배열에 저장하여 다시 그것을 찾을 때 배열에 저장했던 값을 리턴해주면 된다.
```cpp
int d[100]; // 어딘가에 메모하는 공간
fill(d, d + 100, -1); // 메모리 공간을 -1로 초기화, -1의 의미는 아직 계산을 한 적이 없다는 뜻
int Fibonacci(int n)
{
  if(x == 1 || x == 2) return 1;
  // 이미 계산한 적이 있다면 반환
  if(d[n] != -1) return d[n];
  // 아니라면 계산하고 메모해놓는다.
  d[n] = Fibonacci(n - 1) + Fibonacci(n - 2);
  return d[n];
}
```
이렇게 구현하면, 딱 한 번씩만 계산되기 때문에 데이터의 개수가 N일 때 시간 복잡도는 `O(N)`으로 줄일 수 있다.    
보통 다이나믹 프로그래밍의 시간 복잡도 계산은 이렇게 한다.    
`함수 호출` x `함수의 시간 복잡도` => `총 시간 복잡도`    
예를 들어서 피보나치 수열의 데이터가 N개 있을 때    
총 N번의 함수 호출이 일어나고 함수 내부에서 계산하는 시간 복잡도는 `O(1)`이기 때문에 총 시간 복잡도는 N x O(1) = O(N)이 된다.

### 다이나믹 프로그래밍 풀이 방식 2가지
* Top-down 방식
  + 큰 문제를 풀기 위해 작은 문제를 호출하면서 풀어가는 과정
  + 보통 재귀함수로 짤 때, 탑다운 방식이라고 하며 이 때 메모리를 저장하는 개념을 `Memoization`이라고 한다.
* Bottom-up 방식
  + 작은 문제부터 해결하면서 점차 큰 문제도 해결할 수 있다는 과정
  + 보통 반복문으로 짤 때, 바텀업 방식이라고 하며 마찬가지로 메모리를 저장하는 자료구조가 필요하다.
  
### 다이나믹 프로그래밍의 특징
* 큰 문제를 작은 문제로 나눌 수 있다.
  + 부분 문제가 겹친다는 의미이기도 하다. `Overlapping Subproblem`
* 작은 문제의 정답이 그것을 포함하는 큰 문제에서도 같은 정답이다.
  + 작은 문제의 정답이 항상 같다는 의미이다. `Optimal SubStructure`
  
### 다이나믹 프로그래밍의 팁
중복 계산이 과도하게 많이 발생하는 경우 -> 메모리제이션 이용(구했던 답을 어딘가에 저장해놓고 다시 사용하자!)

